<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta id="meta-theme-color" name="theme-color" content="#F2A5FF" />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;500;700;900&display=swap"
      rel="stylesheet"
    />

    <link rel="icon" href="/favicon.ico" sizes="any" />
    <link rel="icon" href="/favicon.svg" type="image/svg+xml" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="manifest" href="/site.webmanifest" />

    <title>Play 2048</title>
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
        font-family: "Be Vietnam Pro", sans-serif;
        -webkit-tap-highlight-color: transparent;
      }
      .brat *,
      .brat *::before,
      .brat *::after {
        font-family: "Arial";
      }

      :root {
        --black: #000000;
        --black-on-theme: #000000;
        --white: #ffffff;
        --light-gray: #e5e5e5;
        --lightest-gray: #f1f1f1;
        --gray: #a3a3a3;
        --green: #3eb23e;
        --light-green: #a3fab3;
        --yellow: #d3b342;
        --theme: #535353;
        --brat: #89cc04;

        --columnsize: 4;
        --rowsize: 4;
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --black: #e2e2e2;
          --white: #1c1c1c;
          --light-gray: #4c4c4c;
          --lightest-gray: #2f2f2f;
          --light-green: #3e5c3f;
        }
      }

      body {
        touch-action: none;

        display: grid;
        place-content: center;

        margin: 0;
        padding: 0;

        font-size: 1rem;

        background-color: var(--white);
        color: var(--black);
        stroke: var(--black);
      }

      h1,
      h2,
      h3,
      h4,
      h5,
      h6 {
        margin: 0;
      }
      h1 {
        font-size: 1.375rem;
        font-weight: 900;
        line-height: 2rem;
      }
      .brat h1 {
        transform: scaleY(1.35);
        filter: blur(0.5px);
      }
      nav h1 {
        color: var(--black-on-theme);
      }

      .dialog {
        appearance: none;
        border: none;
        outline: none;

        margin: 0;
        padding: 0;

        width: 100vw;
        height: 100vh;
        max-width: 100vw;
        max-height: 100vh;

        font-size: 0.75rem;

        background-color: var(--white);
        color: var(--black);
        stroke: var(--black);
      }
      .dialog[open] {
        display: flex;
        flex-flow: column nowrap;
      }

      .one-pane {
        height: 100%;
        overflow-y: auto;

        display: grid;
        grid-template-columns: 1fr;
        justify-content: flex-start;
        gap: 1rem;
        padding: 1rem;
      }
      .one-pane-two-pane {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
      }
      .one-pane-two-pane.centered {
        align-items: center;
      }

      .two-pane {
        height: 100%;
        overflow-y: auto;

        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
        padding: 1rem;
      }

      .pane {
        display: flex;
        flex-flow: column nowrap;
        gap: 1rem;
      }
      .pane .card {
        border-radius: 0.5rem;
        padding: 0.5rem;
        white-space: nowrap;
      }
      .pane .button {
        width: 100%;
      }

      .button {
        appearance: none;
        border: none;
        outline: none;

        border-radius: 0.5rem;
        color: var(--black);
        cursor: pointer;
        font-size: 1rem;
        padding: 0.375rem 0.5rem;

        display: flex;
        flex-flow: row nowrap;
        align-items: center;
        justify-content: space-between;
      }
      .button:disabled {
        cursor: not-allowed;
        opacity: 0.4;
      }
      .button.small {
        font-size: 0.75rem;
      }
      .button svg {
        display: block;
      }
      .button span {
        padding: 0;
        text-align: left;
      }
      .brat .button span {
        transform: scaleY(1.15);
        filter: blur(0.25px);
      }

      .checkbox {
        display: flex;
        flex-flow: row nowrap;
        align-items: center;
        gap: 0.25rem;
      }

      .strong {
        font-weight: bold;
      }
      .light-gray {
        background-color: var(--light-gray);
      }
      .lightest-gray {
        background-color: var(--lightest-gray);
      }
      .gray {
        background-color: var(--gray);
        color: var(--black-on-theme);
        stroke: var(--black-on-theme);
      }
      .white {
        background-color: var(--white);
      }
      .green {
        background-color: var(--green);
        color: var(--black-on-theme);
        stroke: var(--black-on-theme);
      }
      .light-green {
        background-color: var(--light-green);
      }
      .theme {
        background-color: var(--theme);
        color: var(--black-on-theme);
        stroke: var(--black-on-theme);
      }
      .accent {
        background-color: var(--theme);
        filter: brightness(0.7);
        color: var(--black-on-theme);
        stroke: var(--black-on-theme);
      }
      .yellow {
        background-color: var(--yellow);
        color: var(--black-on-theme);
        stroke: var(--black-on-theme);
      }
      .yellow-color {
        color: var(--yellow);
      }

      .sticky {
        position: sticky;
        top: 0;
      }
      .hidden {
        display: none;
      }

      .nav {
        width: 100%;
        padding: 1rem;

        display: flex;
        flex-flow: row nowrap;
        align-items: center;
        justify-content: space-between;
      }
      .nav-buttons {
        display: flex;
        flex-flow: row nowrap;
        align-items: center;
        gap: 0.5rem;

        flex: 1 1 0;
      }
      .nav-buttons.left {
        justify-content: start;
      }
      .nav-buttons.right {
        justify-content: end;
      }

      .icon-group {
        display: flex;
        flex-flow: row nowrap;
        align-items: center;
        gap: 0.375rem;
      }

      main#container {
        width: 100vw;
        height: 100vh;

        display: flex;
        flex-flow: column nowrap;
      }

      nav.nav {
        background-color: var(--theme);
      }

      section#game {
        width: 100%;
        height: 100%;
        flex-grow: 1;

        display: grid;
        grid-template-rows: 1fr;
        align-items: center;
        justify-content: stretch;
        padding: 2rem;
      }

      #board-container {
        position: relative;
        overflow: hidden;

        height: 100%;
        width: 100%;
      }
      :where(.reset > div:not(#reset)) {
        opacity: 0.1;
        transition: 205ms ease-out;
      }
      .board {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        width: min(100%, 30rem);

        display: grid;
        grid-template-columns: repeat(var(--rowsize, 4), 1fr);
        grid-template-rows: repeat(var(--columnsize, 4), 1fr);
        gap: min(4vw, 1rem);

        padding: min(4vw, 1rem);
      }
      .board.invisible {
        opacity: 0;
      }
      #board {
        background-color: var(--lightest-gray);
        border-radius: 0.25rem;
      }
      #anim {
        pointer-events: none;
      }
      #state {
        pointer-events: none;
      }
      #reset {
        display: flex;
        flex-flow: column nowrap;
        align-items: center;
        pointer-events: none;
      }
      .reset #reset {
        pointer-events: auto;
      }
      .board-square,
      .board-piece {
        width: 100%;
        height: 100%;
        aspect-ratio: 1 / 1;
        border-radius: 0.125rem;
      }
      .board-square {
        background-color: var(--light-gray);
      }

      .board-piece {
        display: grid;
        place-content: center;
        overflow: hidden;

        font-size: min(6vw, 2.5rem);
        font-weight: bold;
      }
      .board-piece.invisible {
        visibility: hidden;
      }
      .board-piece.unstyled {
        background-color: var(--theme);
        color: var(--black-on-theme);
      }
      .board-piece.plain {
        background-color: var(--background);
        color: var(--color);
      }
      .board-piece.brat {
        background-color: var(--brat);
        color: black;
      }
      .board-piece.brat span {
        transform: scaleY(1.35) scale(0.85);
        filter: blur(0.75px);
        text-align: justify;
      }

      #overview-themes {
        display: flex;
        flex-flow: column nowrap;
        gap: 0.5rem;
      }
    </style>
  </head>
  <body>
    <main id="container">
      <nav class="nav">
        <div class="nav-buttons left">
          <button id="overview-button" class="accent button">
            <svg
              width="20"
              height="20"
              viewBox="0 0 20 20"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M1.875 10L9.33667 2.5375C9.70333 2.17166 10.2967 2.17166 10.6625 2.5375L18.125 10M3.75 8.125V16.5625C3.75 17.08 4.17 17.5 4.6875 17.5H8.125V13.4375C8.125 12.92 8.545 12.5 9.0625 12.5H10.9375C11.455 12.5 11.875 12.92 11.875 13.4375V17.5H15.3125C15.83 17.5 16.25 17.08 16.25 16.5625V8.125M6.875 17.5H13.75"
                stroke-width="1.5"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
          </button>
        </div>
        <h1>2048</h1>
        <div class="nav-buttons right"></div>
      </nav>
      <section id="game">
        <div id="board-container">
          <div id="board" class="board">
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
          </div>
          <div id="anim" class="board"></div>
          <div id="state" class="board"></div>
          <div id="reset" class="board invisible">
            <span id="reset-text"></span>
            <button id="reset-button" class="theme button">
              Start new game
            </button>
          </div>
        </div>
      </section>
    </main>

    <dialog id="overview-dialog" class="dialog">
      <div class="nav">
        <h1>Overview</h1>
        <button id="overview-close-button" class="light-gray button">
          <svg
            width="20"
            height="20"
            viewBox="0 0 20 20"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              d="M5 15L15 5M5 5L15 15"
              stroke-width="1.5"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
        </button>
      </div>
      <div class="two-pane">
        <div class="pane">
          <div class="icon-group">
            <svg
              width="22"
              height="22"
              viewBox="0 0 24 24"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M4.098 19.902a3.75 3.75 0 0 0 5.304 0l6.401-6.402M6.75 21A3.75 3.75 0 0 1 3 17.25V4.125C3 3.504 3.504 3 4.125 3h5.25c.621 0 1.125.504 1.125 1.125v4.072M6.75 21a3.75 3.75 0 0 0 3.75-3.75V8.197M6.75 21h13.125c.621 0 1.125-.504 1.125-1.125v-5.25c0-.621-.504-1.125-1.125-1.125h-4.072M10.5 8.197l2.88-2.88c.438-.439 1.15-.439 1.59 0l3.712 3.713c.44.44.44 1.152 0 1.59l-2.879 2.88M6.75 17.25h.008v.008H6.75v-.008Z"
                stroke-width="1.5"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
            <strong>Themes</strong>
          </div>
          <div id="overview-themes"></div>
          <button id="overview-new-theme" class="small light-gray button">
            <span>New theme</span>
            <svg
              width="15"
              height="15"
              viewBox="0 0 15 15"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M7.5 2.8125V12.1875M12.1875 7.5H2.8125"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
          </button>
          <button id="overview-clear-data" class="small light-gray button">
            <span>Clear data</span>
            <svg
              width="15"
              height="15"
              viewBox="0 0 24 24"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
          </button>
        </div>
        <div class="pane">
          <div class="icon-group">
            <svg
              width="23"
              height="22"
              viewBox="0 0 24 24"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M9.53 16.122a3 3 0 0 0-5.78 1.128 2.25 2.25 0 0 1-2.4 2.245 4.5 4.5 0 0 0 8.4-2.245c0-.399-.078-.78-.22-1.128Zm0 0a15.998 15.998 0 0 0 3.388-1.62m-5.043-.025a15.994 15.994 0 0 1 1.622-3.395m3.42 3.42a15.995 15.995 0 0 0 4.764-4.648l3.876-5.814a1.151 1.151 0 0 0-1.597-1.597L14.146 6.32a15.996 15.996 0 0 0-4.649 4.763m3.42 3.42a6.776 6.776 0 0 0-3.42-3.42"
                stroke-width="1.5"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
            <strong>Theme editor</strong>
          </div>
          <div id="theme-editor">
            <span>Coming soon!</span>
            <form id="theme-editor-form"></form>
          </div>
        </div>
      </div>
    </dialog>
  </body>
  <script id="variables">
    const Constants = {
      RowSize: 4,
      ColumnSize: 4,
      PiecePaddingPercent: 0.04,
      HigherTierProbability: 0.1,
      MaxLevels: 11,
      DefaultTheme: "Default",
      DefaultThemes: {
        Default: {
          theme: "#f2a5ff",
          map: {
            [1]: {
              type: "text",
              format: "plain",
              background: "#f2a5ff",
              color: "#000000",
              value: "2",
            },
            [2]: {
              type: "text",
              format: "plain",
              background: "#f2a5ff",
              color: "#000000",
              value: "4",
            },
            [3]: {
              type: "text",
              format: "plain",
              background: "#f2a5ff",
              color: "#000000",
              value: "8",
            },
            [4]: {
              type: "text",
              format: "plain",
              background: "#f2a5ff",
              color: "#000000",
              value: "16",
            },
            [5]: {
              type: "text",
              format: "plain",
              background: "#f2a5ff",
              color: "#000000",
              value: "32",
            },
            [6]: {
              type: "text",
              format: "plain",
              background: "#f2a5ff",
              color: "#000000",
              value: "64",
            },
            [7]: {
              type: "text",
              format: "plain",
              background: "#f2a5ff",
              color: "#000000",
              value: "128",
            },
            [8]: {
              type: "text",
              format: "plain",
              background: "#f2a5ff",
              color: "#000000",
              value: "256",
            },
            [9]: {
              type: "text",
              format: "plain",
              background: "#f2a5ff",
              color: "#000000",
              value: "512",
            },
            [10]: {
              type: "text",
              format: "plain",
              background: "#f2a5ff",
              color: "#000000",
              value: "1024",
            },
            [11]: {
              type: "text",
              format: "plain",
              background: "#f2a5ff",
              color: "#000000",
              value: "2048",
            },
          },
        },
        BRAT: {
          theme: "#89cc04",
          map: {
            [1]: {
              type: "text",
              format: "brat",
              value: "2",
            },
            [2]: {
              type: "text",
              format: "brat",
              value: "4",
            },
            [3]: {
              type: "text",
              format: "brat",
              value: "8",
            },
            [4]: {
              type: "text",
              format: "brat",
              value: "16",
            },
            [5]: {
              type: "text",
              format: "brat",
              value: "32",
            },
            [6]: {
              type: "text",
              format: "brat",
              value: "64",
            },
            [7]: {
              type: "text",
              format: "brat",
              value: "128",
            },
            [8]: {
              type: "text",
              format: "brat",
              value: "256",
            },
            [9]: {
              type: "text",
              format: "brat",
              value: "512",
            },
            [10]: {
              type: "text",
              format: "brat",
              value: "1024",
            },
            [11]: {
              type: "text",
              format: "brat",
              value: "2048",
            },
          },
        },
        ["Brat and it's the same but there's three more songs so it's not"]: {
          theme: "#ffffff",
          map: {
            [1]: {
              type: "text",
              format: "brat",
              value: "I think about\nit all the time",
            },
            [2]: {
              type: "text",
              format: "brat",
              value: "Von dutch",
            },
            [3]: {
              type: "text",
              format: "brat",
              value: "360",
            },
            [4]: {
              type: "text",
              format: "brat",
              value: "Mean girls",
            },
            [5]: {
              type: "text",
              format: "brat",
              value: "365",
            },
            [6]: {
              type: "text",
              format: "brat",
              value: "Club classics",
            },
            [7]: {
              type: "text",
              format: "brat",
              value: "Girl, so confusing",
            },
            [8]: {
              type: "text",
              format: "brat",
              value: "b2b",
            },
            [9]: {
              type: "text",
              format: "brat",
              value: "So I",
            },
            [10]: {
              type: "text",
              format: "brat",
              value: "Spring breakers",
            },
            [11]: {
              type: "text",
              format: "brat",
              value: "Guess",
            },
          },
        },
        Cupcake: {
          theme: "#f67098",
        },
      },
      KeyBindings: {
        up: ["ArrowUp", "w"],
        down: ["ArrowDown", "s"],
        left: ["ArrowLeft", "a"],
        right: ["ArrowRight", "d"],
      },
      Transforms: {
        up: (px) => `translateY(calc(-1 * ${px}px))`,
        down: (px) => `translateY(${px}px)`,
        left: (px) => `translateX(calc(-1 * ${px}px))`,
        right: (px) => `translateX(${px}px)`,
      },
    };

    const AppState = {
      currentThemeKey: undefined,
    };

    let GameDict = undefined;
    let ThemeHistory = {};
    let ThemeState = {};
    let GameState = {
      /** [t o p  r o w , ... , ... , b o t t o m  r o w] */
      board: new Array(Constants.RowSize * Constants.ColumnSize).fill(0),
    };
    let SwipeState = {
      active: false,
    };

    const Bindings = {
      Meta: {
        Root: document.documentElement,
        Theme: document.getElementById("meta-theme-color"),
      },
      Control: {
        OverviewButton: {
          Element: document.getElementById("overview-button"),
          Listener: undefined,
        },
        OverviewCloseButton: {
          Element: document.getElementById("overview-close-button"),
          Listener: undefined,
        },
        OverviewNewThemeButton: {
          Element: document.getElementById("overview-new-theme"),
          Listener: undefined,
        },
        OverviewClearDataButton: {
          Element: document.getElementById("overview-clear-data"),
          Listener: undefined,
        },
        ResetButton: {
          Element: document.getElementById("reset-button"),
          Listener: undefined,
        },
      },
      Dialogs: {
        OverviewDialog: document.getElementById("overview-dialog"),
        OverviewThemes: document.getElementById("overview-themes"),
        OverviewThemeEditor: document.getElementById(
          "overview-theme-editor-form"
        ),
      },
      Board: {
        Container: document.getElementById("board-container"),
        Board: document.getElementById("board"),
        Animation: document.getElementById("anim"),
        State: document.getElementById("state"),
        Reset: document.getElementById("reset"),
        ResetText: document.getElementById("reset-text"),
        BoardTouchStart: {
          Element: document.getElementById("board"),
          Listener: undefined,
        },
        BoardTouchMove: {
          Element: document.getElementById("board"),
          Listener: undefined,
        },
        BoardTouchEnd: {
          Element: document.getElementById("board"),
          Listener: undefined,
        },
      },
      Document: {
        Element: document,
        Listener: undefined,
      },
    };
  </script>
  <script id="gameplay">
    const moveColumnOrRow = (columnOrRow, moveLeft = false) => {
      const normalized = moveLeft ? columnOrRow : columnOrRow.reverse();

      let lastSeen;
      let lastSeenIndex;
      const output = [];
      const diff = new Array(normalized.length).fill(0);
      const combined = new Array(normalized.length).fill(0);

      for (let i = 0; i < normalized.length; i++) {
        let char = normalized[i];

        if (char === 0) continue;

        if (lastSeen) {
          diff[lastSeenIndex] = lastSeenIndex - output.length;
          if (char === lastSeen) {
            diff[i] = i - output.length;
            combined[output.length] = char + 1;
            output.unshift(char + 1);
            lastSeen = undefined;
            lastSeenIndex = undefined;
          } else {
            output.unshift(lastSeen);
            lastSeen = char;
            lastSeenIndex = i;
          }
        } else {
          lastSeen = char;
          lastSeenIndex = i;
        }
      }

      if (lastSeen) {
        diff[lastSeenIndex] = lastSeenIndex - output.length;
        output.unshift(lastSeen);
      }

      const padded = [
        ...new Array(normalized.length - output.length).fill(0),
        ...output,
      ];

      return {
        board: moveLeft ? padded.reverse() : padded,
        diff: moveLeft ? diff : diff.reverse(),
        combined: moveLeft ? combined : combined.reverse(),
      };
    };

    const boardToColumns = (board) => {
      const columns = new Array(Constants.RowSize)
        .fill(0)
        .map(() => new Array(Constants.ColumnSize));
      for (let i = 0; i < board.length; i++) {
        columns[i % Constants.RowSize][Math.floor(i / Constants.ColumnSize)] =
          board[i];
      }
      return columns;
    };

    const columnsToBoard = (columns) => {
      const output = {
        board: [],
        diff: [],
        combined: [],
      };
      for (let i = 0; i < columns.length; i++) {
        for (let j = 0; j < columns[i].board.length; j++) {
          output.board[i + Constants.RowSize * j] = columns[i].board[j];
          output.diff[i + Constants.RowSize * j] = columns[i].diff[j];
          output.combined[i + Constants.RowSize * j] = columns[i].combined[j];
        }
      }
      return output;
    };

    const boardToRows = (board) => {
      const rows = new Array(Constants.ColumnSize)
        .fill(0)
        .map(() => new Array(Constants.RowSize));
      for (let i = 0; i < board.length; i++) {
        rows[Math.floor(i / Constants.RowSize)][i % Constants.ColumnSize] =
          board[i];
      }
      return rows;
    };

    const rowsToBoard = (rows) => {
      const output = {
        board: [],
        diff: [],
        combined: [],
      };
      for (let i = 0; i < rows.length; i++) {
        for (let j = 0; j < rows[i].board.length; j++) {
          output.board[i * Constants.RowSize + j] = rows[i].board[j];
          output.diff[i * Constants.RowSize + j] = rows[i].diff[j];
          output.combined[i * Constants.RowSize + j] = rows[i].combined[j];
        }
      }
      return output;
    };

    const calculateBoard = (board) => {
      return {
        up: columnsToBoard(
          boardToColumns(board).map((column) => moveColumnOrRow(column, true))
        ),
        down: columnsToBoard(
          boardToColumns(board).map((column) => moveColumnOrRow(column, false))
        ),
        left: rowsToBoard(
          boardToRows(board).map((row) => moveColumnOrRow(row, true))
        ),
        right: rowsToBoard(
          boardToRows(board).map((row) => moveColumnOrRow(row, false))
        ),
      };
    };

    const addNewPieces = (board, pieces = 1) => {
      const emptySquares = board.filter((square) => square === 0).length;
      const targetEmptySquares = new Set();

      if (emptySquares === 0) {
        return {
          board,
          targetSquares: new Set(),
        };
      }

      while (targetEmptySquares.size < pieces) {
        targetEmptySquares.add(Math.floor(Math.random() * emptySquares));
      }

      const targetSquares = new Set();
      let currentEmptySquare = 0;
      for (let i = 0; i < GameState.board.length; i++) {
        if (board[i] !== 0) continue;

        if (targetEmptySquares.has(currentEmptySquare)) {
          targetSquares.add(i);
          board[i] = Math.random() < Constants.HigherTierProbability ? 2 : 1;
        }

        currentEmptySquare++;
      }

      return {
        board,
        targetSquares,
      };
    };

    const moveBoard = async (move) => {
      if (!GameState.premove)
        GameState.premove = calculateBoard(GameState.board);

      const state = GameState.premove[move];
      const isValidMove = state.diff.some((diff) => diff !== 0);

      if (!isValidMove) return;

      const previousBoard = GameState.board;

      const { board: newBoard, targetSquares } = addNewPieces(state.board);

      GameState.board = newBoard;

      GameState.premove = calculateBoard(GameState.board);

      if (GameState.board.some((square) => square >= Constants.MaxLevels)) {
        GameState.status = "won";
      }

      if (
        Object.values(GameState.premove).every(({ diff }) =>
          diff.every((diff) => diff === 0)
        )
      ) {
        GameState.status = "lost";
      }

      await animateState(
        previousBoard,
        newBoard,
        targetSquares,
        state.diff,
        state.combined,
        move
      );

      updateDisplayState();
    };

    const switchTheme = async (themeKey) => {
      if (!(themeKey in ThemeHistory))
        throw new Error("Attempted to switch to nonexistent theme!");

      AppState.currentThemeKey = themeKey;
      ThemeState = ThemeHistory[AppState.currentThemeKey];

      updateDisplayState();
    };

    const newTheme = async () => {
      const uuid = crypto.randomUUID().slice(0, 6);

      ThemeHistory[uuid] = {
        theme: "#f2a5ff",
      };

      await switchTheme(uuid);
    };

    const reset = async () => {
      const emptyBoard = () =>
        new Array(Constants.RowSize * Constants.ColumnSize).fill(0);

      const { board, targetSquares } = addNewPieces(emptyBoard(), 2);

      GameState = {
        board,
      };

      await animateState(
        emptyBoard(),
        GameState.board,
        targetSquares,
        emptyBoard(),
        emptyBoard()
      );

      updateDisplayState();
    };

    const load = async () => {
      const emptyBoard = () =>
        new Array(Constants.RowSize * Constants.ColumnSize).fill(0);

      GameState = {
        board: emptyBoard(),
      };

      const localGameStateString = window.localStorage.getItem("2048_State");

      if (localGameStateString) {
        GameState = JSON.parse(localGameStateString);
      } else {
        const { board } = addNewPieces(emptyBoard(), 2);

        GameState = {
          board,
        };
      }

      await animateState(
        emptyBoard(),
        GameState.board,
        GameState.board.reduce(
          (set, square, index) => (square === 0 ? set : set.add(index)),
          new Set()
        ),
        emptyBoard(),
        emptyBoard()
      );

      const localThemeHistoryString =
        window.localStorage.getItem("2048_History");

      if (localThemeHistoryString) {
        ThemeHistory = JSON.parse(localThemeHistoryString);
      }

      for (const [key, theme] of Object.entries(Constants.DefaultThemes)) {
        ThemeHistory[key] = theme;
      }

      const lastThemeHistoryString = window.localStorage.getItem("2048_Theme");

      await switchTheme(lastThemeHistoryString ?? Constants.DefaultTheme);
    };

    const save = () => {
      window.localStorage.setItem("2048_Theme", AppState.currentThemeKey);
      window.localStorage.setItem("2048_State", JSON.stringify(GameState));
      window.localStorage.setItem("2048_History", JSON.stringify(ThemeHistory));
    };

    const del = () => {
      window.localStorage.removeItem("2048_Theme", AppState.currentThemeKey);
      window.localStorage.removeItem("2048_State", JSON.stringify(GameState));
      window.localStorage.removeItem(
        "2048_History",
        JSON.stringify(ThemeHistory)
      );
    };

    const getThemedPiece = (state) => {
      if (state === 0) {
        return `<div class="board-piece invisible"><span>${Math.pow(
          2,
          state
        )}</span></div>`;
      }

      if (!ThemeState.map || !ThemeState.map[state]) {
        return `<div class="board-piece unstyled"><span>${Math.pow(
          2,
          state
        )}</span></div>`;
      }

      const themedPiece = ThemeState.map[state];

      if (themedPiece.type === "text") {
        if (themedPiece.format === "plain") {
          return `<div class="board-piece plain" style="--background: ${themedPiece.background}; --color: ${themedPiece.color}"><span>${themedPiece.value}</span></div>`;
        }

        if (themedPiece.format === "brat") {
          return `<div class="board-piece brat"><span>${themedPiece.value}</span></div>`;
        }
      }
    };

    const populateNodeWithBoard = (node, board) => {
      node.innerHTML = board
        .map((state, index) => getThemedPiece(state))
        .join("");

      node.querySelectorAll(".board-piece").forEach((piece) => {
        const span = piece.querySelector("span");

        const pieceWidth = piece.getBoundingClientRect().width;
        const pieceHeight = piece.getBoundingClientRect().height;
        const spanWidth = span.getBoundingClientRect().width;
        const spanHeight = span.getBoundingClientRect().height;

        const widthOverflow = spanWidth / pieceWidth;
        const heightOverflow = spanHeight / pieceHeight;
        const largestOverflow = Math.max(widthOverflow, heightOverflow);

        if (largestOverflow > 1 - 2 * Constants.PiecePaddingPercent) {
          const scaleFactor =
            (1 - 2 * Constants.PiecePaddingPercent) / largestOverflow;
          span.style.scale = scaleFactor;
        }
      });
    };

    const animateState = async (
      previousBoard,
      newBoard,
      targetSquares,
      diff,
      combined,
      move = "left"
    ) => {
      populateNodeWithBoard(Bindings.Board.Animation, previousBoard);

      const moveAnimationPieces = Array.from(
        document.querySelectorAll("#anim .board-piece")
      );

      Bindings.Board.Animation.classList.remove("invisible");
      Bindings.Board.State.classList.add("invisible");

      const movePx =
        parseFloat(getComputedStyle(Bindings.Board.Animation).gap) +
        moveAnimationPieces[0].getBoundingClientRect().width;

      const moveAnimationPromises = [];

      for (let i = 0; i < diff.length; i++) {
        if (diff[i] > 0) {
          const moveAnimation = moveAnimationPieces[i].animate(
            [
              { transform: "translateX(0) translateY(0)" },
              { transform: Constants.Transforms[move](diff[i] * movePx) },
            ],
            { duration: 105, easing: "ease-in", fill: "forwards" }
          );
          moveAnimationPromises.push(moveAnimation.finished);
        }
      }

      await Promise.all(moveAnimationPromises);

      populateNodeWithBoard(Bindings.Board.Animation, newBoard);

      const growAnimationPieces = Array.from(
        document.querySelectorAll("#anim .board-piece")
      );

      const growAnimationPromises = [];

      for (let i = 0; i < combined.length; i++) {
        if (targetSquares.has(i) || combined[i] > 0) {
          growAnimationPieces[i].classList.remove("invisible");
          const growAnimation = growAnimationPieces[i].animate(
            [{ transform: "scale(0.6)" }, { transform: "scale(1)" }],
            { duration: 105, easing: "ease-out", fill: "forwards" }
          );
          growAnimationPromises.push(growAnimation.finished);
        }
      }

      await Promise.all(growAnimationPromises);
    };

    const updateDisplayState = () => {
      Bindings.Meta.Root.style.setProperty("--theme", ThemeState.theme);
      Bindings.Meta.Theme.setAttribute("content", ThemeState.theme);

      if (
        ThemeState.map &&
        Object.values(ThemeState.map).some(
          (themedPiece) =>
            themedPiece.type === "text" && themedPiece.format === "brat"
        )
      ) {
        document.body.classList.add("brat");
      } else {
        document.body.classList.remove("brat");
      }

      if (GameState.status) {
        Bindings.Board.ResetText.innerHTML =
          GameState.status === "won"
            ? "You won! Well played."
            : "No more valid moves!";
        Bindings.Board.Container.classList.add("reset");
        Bindings.Board.Reset.classList.remove("invisible");
      } else {
        Bindings.Board.ResetText.innerHTML = "";
        Bindings.Board.Container.classList.remove("reset");
        Bindings.Board.Reset.classList.add("invisible");
      }

      Bindings.Board.State.classList.remove("invisible");
      Bindings.Board.Animation.classList.add("invisible");

      populateNodeWithBoard(Bindings.Board.State, GameState.board);

      Bindings.Dialogs.OverviewThemes.innerHTML = Object.entries(ThemeHistory)
        .sort()
        .reverse()
        .reduce(
          (innerHTML, [key, theme]) =>
            (innerHTML += `<button data-theme-key="${key}" class="small ${
              AppState.currentThemeKey === key ? "theme" : "light-gray"
            } button">
                <span>
                  <strong>
                    ${key}
                  </strong>
                </span>
              </button>`),
          ""
        );

      updateButtonBindings();

      save();
    };

    const clearBinding = (binding, event = "pointerdown") => {
      binding.Element.removeEventListener(event, binding.Listener);
    };

    const updateBinding = (binding, callback, event = "pointerdown") => {
      binding.Element.removeEventListener(event, binding.Listener);
      binding.Listener = callback;
      binding.Element.addEventListener(event, binding.Listener);
    };

    const updateButtonBindings = () => {
      updateBinding(
        Bindings.Document,
        (e) => {
          if (!e.metaKey && e.key === "r") reset();

          if (!GameState.status) {
            Object.entries(Constants.KeyBindings).forEach(([move, keys]) =>
              keys.includes(e.key) ? moveBoard(move) : {}
            );
          }
        },
        "keydown"
      );

      updateBinding(
        Bindings.Board.BoardTouchStart,
        (e) => {
          if (GameState.status) return;

          SwipeState.active = true;
          SwipeState.x = e.clientX;
          SwipeState.y = e.clientY;
        },
        "pointerdown"
      );
      updateBinding(
        Bindings.Board.BoardTouchEnd,
        (e) => {
          if (GameState.status) return;

          if (SwipeState.active) {
            SwipeState.active = false;
            const deltaX = e.clientX - SwipeState.x;
            const deltaY = e.clientY - SwipeState.y;

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
              if (Math.abs(deltaX) > 16)
                moveBoard(deltaX > 0 ? "right" : "left");
            } else {
              if (Math.abs(deltaY) > 16) moveBoard(deltaY > 0 ? "down" : "up");
            }
          }
        },
        "pointerup"
      );

      Bindings.Dialogs.OverviewDialog.querySelectorAll(
        "button[data-theme-key]"
      ).forEach((button) =>
        button.addEventListener("click", () => {
          const key = button.dataset.themeKey;

          if (
            AppState.currentThemeKey === key &&
            AppState.currentThemeKey !== AppState.now &&
            confirm(`Delete theme ${key.replace("+", " • ")}?`)
          ) {
            delete ThemeHistory[key];
            switchTheme(Constants.DefaultTheme);
          } else {
            switchTheme(key);
          }
        })
      );
    };

    const updateControlButtonsOnce = () => {
      updateBinding(
        Bindings.Control.OverviewButton,
        () => {
          Bindings.Dialogs.OverviewDialog.showModal();
        },
        "click"
      );
      updateBinding(
        Bindings.Control.OverviewCloseButton,
        () => {
          Bindings.Dialogs.OverviewDialog.close();
          Bindings.Control.OverviewButton.Element.blur();
        },
        "click"
      );
      updateBinding(
        Bindings.Control.OverviewNewThemeButton,
        async () => {
          newTheme();
        },
        "click"
      );
      updateBinding(
        Bindings.Control.OverviewClearDataButton,
        async () => {
          del();
        },
        "click"
      );
      updateBinding(
        Bindings.Control.ResetButton,
        () => {
          reset();
        },
        "click"
      );
    };
  </script>
  <script id="run">
    const play = async () => {
      await load();

      updateControlButtonsOnce();

      if ("serviceWorker" in navigator) {
        await navigator.serviceWorker.register("./sw.js", {
          scope: "/",
        });
      }
    };

    play();
  </script>
</html>
