<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <meta id="meta-theme-color" name="theme-color" content="#F2A5FF" />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Be+Vietnam+Pro:wght@400;500;700;900&display=swap"
      rel="stylesheet"
    />

    <link rel="icon" href="/favicon.ico" sizes="any" />
    <link rel="icon" href="/favicon.svg" type="image/svg+xml" />
    <link rel="apple-touch-icon" href="/apple-touch-icon.png" />
    <link rel="manifest" href="/site.webmanifest" />

    <title>Play 2048</title>
    <style>
      *,
      *::before,
      *::after {
        box-sizing: border-box;
        font-family: "Be Vietnam Pro", sans-serif;
        -webkit-tap-highlight-color: transparent;
      }
      .brat *,
      .brat *::before,
      .brat *::after {
        font-family: "Arial";
      }

      :root {
        --black: #000000;
        --black-on-theme: #000000;
        --white: #ffffff;
        --light-gray: #e5e5e5;
        --lightest-gray: #f1f1f1;
        --gray: #a3a3a3;
        --green: #3eb23e;
        --light-green: #a3fab3;
        --yellow: #d3b342;
        --theme: #535353;
        --brat: #89cc04;

        --columnsize: 4;
        --rowsize: 4;
      }

      @media (prefers-color-scheme: dark) {
        :root {
          --black: #e2e2e2;
          --white: #1c1c1c;
          --light-gray: #4c4c4c;
          --lightest-gray: #2f2f2f;
          --light-green: #3e5c3f;
        }
      }

      body {
        touch-action: none;

        display: grid;
        place-content: center;

        margin: 0;
        padding: 0;

        font-size: 1rem;

        background-color: var(--white);
        color: var(--black);
        stroke: var(--black);
      }

      h1,
      h2,
      h3,
      h4,
      h5,
      h6 {
        margin: 0;
      }
      h1 {
        font-size: 1.375rem;
        font-weight: 900;
        line-height: 2rem;
      }
      .brat h1 {
        transform: scaleY(1.35);
        filter: blur(0.5px);
      }
      nav h1 {
        color: var(--black-on-theme);
      }

      .dialog {
        appearance: none;
        border: none;
        outline: none;

        margin: 0;
        padding: 0;

        width: 100vw;
        height: 100vh;
        max-width: 100vw;
        max-height: 100vh;

        font-size: 0.75rem;

        background-color: var(--white);
        color: var(--black);
        stroke: var(--black);
      }
      .dialog[open] {
        display: flex;
        flex-flow: column nowrap;
      }

      .one-pane {
        height: 100%;
        overflow-y: auto;

        display: grid;
        grid-template-columns: 1fr;
        justify-content: flex-start;
        gap: 1rem;
        padding: 1rem;
      }
      .one-pane-two-pane {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
      }
      .one-pane-two-pane.centered {
        align-items: center;
      }

      .two-pane {
        height: 100%;
        overflow-y: auto;

        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
        padding: 1rem;
      }

      .pane {
        display: flex;
        flex-flow: column nowrap;
        gap: 1rem;
      }
      .pane .card {
        border-radius: 0.5rem;
        padding: 0.5rem;
        white-space: nowrap;
      }
      .pane .button {
        width: 100%;
      }

      .button {
        appearance: none;
        border: none;
        outline: none;

        border-radius: 0.5rem;
        color: var(--black);
        cursor: pointer;
        font-size: 1rem;
        padding: 0.375rem 0.5rem;

        display: flex;
        flex-flow: row nowrap;
        align-items: center;
        justify-content: space-between;
        gap: 0.375rem;
      }
      .button:disabled {
        cursor: not-allowed;
        opacity: 0.4;
      }
      .button.small {
        font-size: 0.75rem;
      }
      .button svg {
        display: block;
      }
      .button span {
        padding: 0;
        text-align: left;
      }
      .brat .button span {
        transform: scaleY(1.15);
        filter: blur(0.25px);
      }

      .input {
        appearance: none;
        border: none;
        outline: none;

        border-radius: 0.5rem;
        font-size: 1rem;
        padding: 0.375rem 0.5rem;
      }
      .input.small {
        font-size: 0.75rem;
      }

      .checkbox {
        display: flex;
        flex-flow: row nowrap;
        align-items: center;
        gap: 0.25rem;
      }

      .strong {
        font-weight: bold;
      }
      .light-gray {
        background-color: var(--light-gray);
      }
      .lightest-gray {
        background-color: var(--lightest-gray);
      }
      .gray {
        background-color: var(--gray);
        color: var(--black-on-theme);
        stroke: var(--black-on-theme);
      }
      .white {
        background-color: var(--white);
      }
      .green {
        background-color: var(--green);
        color: var(--black-on-theme);
        stroke: var(--black-on-theme);
      }
      .light-green {
        background-color: var(--light-green);
      }
      .theme {
        background-color: var(--theme);
        color: var(--black-on-theme);
        stroke: var(--black-on-theme);
      }
      .accent {
        background-color: var(--theme);
        filter: brightness(0.7);
        color: var(--black-on-theme);
        stroke: var(--black-on-theme);
      }
      .yellow {
        background-color: var(--yellow);
        color: var(--black-on-theme);
        stroke: var(--black-on-theme);
      }
      .yellow-color {
        color: var(--yellow);
      }

      .sticky {
        position: sticky;
        top: 0;
      }
      .hidden {
        display: none;
      }

      .nav {
        width: 100%;
        padding: 1rem;

        display: flex;
        flex-flow: row nowrap;
        align-items: center;
        justify-content: space-between;
      }
      .nav-buttons {
        display: flex;
        flex-flow: row nowrap;
        align-items: center;
        gap: 0.5rem;

        flex: 1 1 0;
      }
      .nav-buttons.left {
        justify-content: start;
      }
      .nav-buttons.right {
        justify-content: end;
      }

      .icon-group {
        display: flex;
        flex-flow: row nowrap;
        align-items: center;
        gap: 0.375rem;
      }

      main#container {
        width: 100vw;
        height: 100vh;

        display: flex;
        flex-flow: column nowrap;
      }

      nav.nav {
        background-color: var(--theme);
      }

      section#game {
        width: 100%;
        height: 100%;
        flex-grow: 1;

        display: grid;
        grid-template-rows: 1fr auto 1fr;
        align-items: center;
        padding: 2rem;
      }

      #score-container,
      #action-container {
        display: flex;
        flex-flow: row nowrap;
        justify-content: center;
        gap: min(8rem, 24vw);
      }

      .score-block {
        display: flex;
        flex-flow: column nowrap;
        align-items: center;
      }

      #board-container {
        position: relative;
        overflow: hidden;

        display: flex;
        justify-content: center;
      }
      :where(.reset > div:not(#reset)) {
        opacity: 0.1;
        transition: 205ms ease-out;
      }
      .board {
        width: min(100%, 30rem);

        display: grid;
        grid-template-columns: repeat(var(--rowsize, 4), 1fr);
        grid-template-rows: repeat(var(--columnsize, 4), 1fr);
        gap: min(4vw, 1rem);

        padding: min(4vw, 1rem);
      }
      .board.invisible {
        opacity: 0;
      }
      #board {
        background-color: var(--lightest-gray);
        border-radius: 0.25rem;
      }
      #anim,
      #state,
      #reset {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);

        pointer-events: none;
      }
      #reset {
        display: flex;
        flex-flow: column nowrap;
        align-items: center;
        pointer-events: none;
      }
      .reset #reset {
        pointer-events: auto;
      }
      .board-square,
      .board-piece {
        width: 100%;
        height: 100%;
        aspect-ratio: 1 / 1;
        border-radius: 0.125rem;
      }
      .board-square {
        background-color: var(--light-gray);
      }

      .board-piece {
        display: grid;
        place-content: center;
        overflow: hidden;

        font-size: min(6vw, 2.5rem);
        font-weight: bold;
      }
      .board-piece.invisible {
        visibility: hidden;
      }
      .board-piece.unstyled {
        background-color: var(--theme);
        color: var(--black-on-theme);
      }
      .board-piece.plain {
        background-color: var(--background);
        color: var(--color);
      }
      .board-piece.brat {
        font-weight: normal;
        background-color: var(--brat);
        color: black;
      }
      .board-piece.brat span {
        transform: scaleY(1.35) scale(0.85);
        filter: blur(0.75px);
        text-align: justify;
      }
      .board-piece.image img {
        width: 100%;
      }

      #overview-themes,
      #theme-editor-form {
        display: flex;
        flex-flow: column nowrap;
        gap: 0.5rem;
      }
    </style>
  </head>
  <body>
    <main id="container">
      <nav class="nav">
        <div class="nav-buttons left">
          <button id="overview-button" class="accent button">
            <svg
              width="20"
              height="20"
              viewBox="0 0 20 20"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M1.875 10L9.33667 2.5375C9.70333 2.17166 10.2967 2.17166 10.6625 2.5375L18.125 10M3.75 8.125V16.5625C3.75 17.08 4.17 17.5 4.6875 17.5H8.125V13.4375C8.125 12.92 8.545 12.5 9.0625 12.5H10.9375C11.455 12.5 11.875 12.92 11.875 13.4375V17.5H15.3125C15.83 17.5 16.25 17.08 16.25 16.5625V8.125M6.875 17.5H13.75"
                stroke-width="1.5"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
          </button>
        </div>
        <h1>2048</h1>
        <div class="nav-buttons right"></div>
      </nav>
      <section id="game">
        <div id="score-container">
          <div class="score-block">
            <span>High score</span>
            <h2 id="high-score">0</h2>
          </div>
          <div class="score-block">
            <span>Score</span>
            <h2 id="score">0</h2>
          </div>
        </div>
        <div id="board-container">
          <div id="board" class="board">
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
            <div class="board-square"></div>
          </div>
          <div id="anim" class="board"></div>
          <div id="state" class="board"></div>
          <div id="reset" class="board invisible">
            <span id="reset-text"></span>
            <span
              >Your final score was: <strong id="reset-score"></strong>!</span
            >
            <button id="reset-button" class="theme button">
              Start new game
            </button>
          </div>
        </div>
        <div id="action-container">
          <button id="action-undo" class="light-gray button">
            <span>Undo</span>
            <svg
              width="20"
              height="20"
              viewBox="0 0 24 24"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M9 15 3 9m0 0 6-6M3 9h12a6 6 0 0 1 0 12h-3"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
          </button>
          <button id="action-reset" class="light-gray button">
            <span>Reset</span>
            <svg
              width="20"
              height="20"
              viewBox="0 0 24 24"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M19.5 12c0-1.232-.046-2.453-.138-3.662a4.006 4.006 0 0 0-3.7-3.7 48.678 48.678 0 0 0-7.324 0 4.006 4.006 0 0 0-3.7 3.7c-.017.22-.032.441-.046.662M19.5 12l3-3m-3 3-3-3m-12 3c0 1.232.046 2.453.138 3.662a4.006 4.006 0 0 0 3.7 3.7 48.656 48.656 0 0 0 7.324 0 4.006 4.006 0 0 0 3.7-3.7c.017-.22.032-.441.046-.662M4.5 12l3 3m-3-3-3 3"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
          </button>
        </div>
      </section>
    </main>

    <dialog id="overview-dialog" class="dialog">
      <div class="nav">
        <h1>Overview</h1>
        <button id="overview-close-button" class="light-gray button">
          <svg
            width="20"
            height="20"
            viewBox="0 0 20 20"
            fill="none"
            xmlns="http://www.w3.org/2000/svg"
          >
            <path
              d="M5 15L15 5M5 5L15 15"
              stroke-width="1.5"
              stroke-linecap="round"
              stroke-linejoin="round"
            />
          </svg>
        </button>
      </div>
      <div class="two-pane">
        <div class="pane">
          <div class="icon-group">
            <svg
              width="22"
              height="22"
              viewBox="0 0 24 24"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M4.098 19.902a3.75 3.75 0 0 0 5.304 0l6.401-6.402M6.75 21A3.75 3.75 0 0 1 3 17.25V4.125C3 3.504 3.504 3 4.125 3h5.25c.621 0 1.125.504 1.125 1.125v4.072M6.75 21a3.75 3.75 0 0 0 3.75-3.75V8.197M6.75 21h13.125c.621 0 1.125-.504 1.125-1.125v-5.25c0-.621-.504-1.125-1.125-1.125h-4.072M10.5 8.197l2.88-2.88c.438-.439 1.15-.439 1.59 0l3.712 3.713c.44.44.44 1.152 0 1.59l-2.879 2.88M6.75 17.25h.008v.008H6.75v-.008Z"
                stroke-width="1.5"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
            <strong>Themes</strong>
          </div>
          <!--button id="overview-new-theme" class="small light-gray button">
            <span>New theme</span>
            <svg
              width="15"
              height="15"
              viewBox="0 0 15 15"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M7.5 2.8125V12.1875M12.1875 7.5H2.8125"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
          </button-->
          <div id="overview-themes"></div>
          <button id="overview-clear-data" class="small light-gray button">
            <span>Clear data</span>
            <svg
              width="15"
              height="15"
              viewBox="0 0 24 24"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
          </button>
        </div>
        <div class="pane">
          <div class="icon-group">
            <svg
              width="23"
              height="22"
              viewBox="0 0 24 24"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M9.53 16.122a3 3 0 0 0-5.78 1.128 2.25 2.25 0 0 1-2.4 2.245 4.5 4.5 0 0 0 8.4-2.245c0-.399-.078-.78-.22-1.128Zm0 0a15.998 15.998 0 0 0 3.388-1.62m-5.043-.025a15.994 15.994 0 0 1 1.622-3.395m3.42 3.42a15.995 15.995 0 0 0 4.764-4.648l3.876-5.814a1.151 1.151 0 0 0-1.597-1.597L14.146 6.32a15.996 15.996 0 0 0-4.649 4.763m3.42 3.42a6.776 6.776 0 0 0-3.42-3.42"
                stroke-width="1.5"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
            <strong>Theme editor</strong>
          </div>
          <span>Coming soon!</span>
          <!--form id="theme-editor-form">
            <input type="text" class="small input" />
          </form>
          <button id="theme-editor-save" form="theme-editor-form" class="small light-gray button">
            <span>Save theme</span>
            <svg
              width="15"
              height="15"
              viewBox="0 0 24 24"
              fill="none"
              xmlns="http://www.w3.org/2000/svg"
            >
              <path
                d="M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m0 12.75h7.5m-7.5 3H12M10.5 2.25H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z"
                stroke-linecap="round"
                stroke-linejoin="round"
              />
            </svg>
          </button-->
        </div>
      </div>
    </dialog>
  </body>
  <script id="variables">
    const Constants = {
      Api: {
        DefaultThemes: "./default.json",
      },
      RowSize: 4,
      ColumnSize: 4,
      PiecePaddingPercent: 0.04,
      HigherTierProbability: 0.1,
      MaxLevels: 11,
      DefaultTheme: "Default",
      KeyBindings: {
        up: ["ArrowUp", "w"],
        down: ["ArrowDown", "s"],
        left: ["ArrowLeft", "a"],
        right: ["ArrowRight", "d"],
      },
      Transforms: {
        up: (px) => `translateY(calc(-1 * ${px}px))`,
        down: (px) => `translateY(${px}px)`,
        left: (px) => `translateX(calc(-1 * ${px}px))`,
        right: (px) => `translateX(${px}px)`,
      },
      MaxScaleIterations: 20,
    };

    let AppState = {
      currentThemeKey: undefined,
      highScore: 0,
    };
    let ThemeHistory = {};
    let ThemeState = {};
    let GameState = {
      /** [t o p  r o w , ... , ... , b o t t o m  r o w] */
      board: new Array(Constants.RowSize * Constants.ColumnSize).fill(0),
      score: 0,
    };
    let SwipeState = {
      active: false,
    };

    const Bindings = {
      Meta: {
        Root: document.documentElement,
        Theme: document.getElementById("meta-theme-color"),
      },
      Control: {
        OverviewButton: {
          Element: document.getElementById("overview-button"),
          Listener: undefined,
        },
        OverviewCloseButton: {
          Element: document.getElementById("overview-close-button"),
          Listener: undefined,
        },
        OverviewNewThemeButton: {
          Element: document.getElementById("overview-new-theme"),
          Listener: undefined,
        },
        OverviewClearDataButton: {
          Element: document.getElementById("overview-clear-data"),
          Listener: undefined,
        },
        ResetButton: {
          Element: document.getElementById("reset-button"),
          Listener: undefined,
        },
      },
      Dialogs: {
        OverviewDialog: document.getElementById("overview-dialog"),
        OverviewThemes: document.getElementById("overview-themes"),
        OverviewThemeEditor: document.getElementById(
          "overview-theme-editor-form"
        ),
      },
      Score: {
        HighScore: document.getElementById("high-score"),
        Score: document.getElementById("score"),
      },
      Board: {
        Container: document.getElementById("board-container"),
        Board: document.getElementById("board"),
        Animation: document.getElementById("anim"),
        State: document.getElementById("state"),
        BoardTouchStart: {
          Element: document.getElementById("board"),
          Listener: undefined,
        },
        BoardTouchMove: {
          Element: document.getElementById("board"),
          Listener: undefined,
        },
        BoardTouchEnd: {
          Element: document.getElementById("board"),
          Listener: undefined,
        },
      },
      Action: {
        Undo: {
          Element: document.getElementById("action-undo"),
          Listener: undefined,
        },
        Reset: {
          Element: document.getElementById("action-reset"),
          Listener: undefined,
        },
      },
      Reset: {
        Board: document.getElementById("reset"),
        Text: document.getElementById("reset-text"),
        Score: document.getElementById("reset-score"),
      },
      Document: {
        Element: document,
        Listener: undefined,
      },
    };
  </script>
  <script id="gameplay">
    const moveColumnOrRow = (columnOrRow, moveLeft = false) => {
      const normalized = moveLeft ? columnOrRow : columnOrRow.reverse();

      let lastSeen;
      let lastSeenIndex;
      const output = [];
      const diff = new Array(normalized.length).fill(0);
      const combined = new Array(normalized.length).fill(0);

      for (let i = 0; i < normalized.length; i++) {
        let char = normalized[i];

        if (char === 0) continue;

        if (lastSeen) {
          diff[lastSeenIndex] = lastSeenIndex - output.length;
          if (char === lastSeen) {
            diff[i] = i - output.length;
            combined[output.length] = char + 1;
            output.unshift(char + 1);
            lastSeen = undefined;
            lastSeenIndex = undefined;
          } else {
            output.unshift(lastSeen);
            lastSeen = char;
            lastSeenIndex = i;
          }
        } else {
          lastSeen = char;
          lastSeenIndex = i;
        }
      }

      if (lastSeen) {
        diff[lastSeenIndex] = lastSeenIndex - output.length;
        output.unshift(lastSeen);
      }

      const padded = [
        ...new Array(normalized.length - output.length).fill(0),
        ...output,
      ];

      return {
        board: moveLeft ? padded.reverse() : padded,
        diff: moveLeft ? diff : diff.reverse(),
        combined: moveLeft ? combined : combined.reverse(),
      };
    };

    const boardToColumns = (board) => {
      const columns = new Array(Constants.RowSize)
        .fill(0)
        .map(() => new Array(Constants.ColumnSize));
      for (let i = 0; i < board.length; i++) {
        columns[i % Constants.RowSize][Math.floor(i / Constants.ColumnSize)] =
          board[i];
      }
      return columns;
    };

    const columnsToBoard = (columns) => {
      const output = {
        board: [],
        diff: [],
        combined: [],
      };
      for (let i = 0; i < columns.length; i++) {
        for (let j = 0; j < columns[i].board.length; j++) {
          output.board[i + Constants.RowSize * j] = columns[i].board[j];
          output.diff[i + Constants.RowSize * j] = columns[i].diff[j];
          output.combined[i + Constants.RowSize * j] = columns[i].combined[j];
        }
      }
      return output;
    };

    const boardToRows = (board) => {
      const rows = new Array(Constants.ColumnSize)
        .fill(0)
        .map(() => new Array(Constants.RowSize));
      for (let i = 0; i < board.length; i++) {
        rows[Math.floor(i / Constants.RowSize)][i % Constants.ColumnSize] =
          board[i];
      }
      return rows;
    };

    const rowsToBoard = (rows) => {
      const output = {
        board: [],
        diff: [],
        combined: [],
      };
      for (let i = 0; i < rows.length; i++) {
        for (let j = 0; j < rows[i].board.length; j++) {
          output.board[i * Constants.RowSize + j] = rows[i].board[j];
          output.diff[i * Constants.RowSize + j] = rows[i].diff[j];
          output.combined[i * Constants.RowSize + j] = rows[i].combined[j];
        }
      }
      return output;
    };

    const calculateBoard = (board) => {
      return {
        up: columnsToBoard(
          boardToColumns(board).map((column) => moveColumnOrRow(column, true))
        ),
        down: columnsToBoard(
          boardToColumns(board).map((column) => moveColumnOrRow(column, false))
        ),
        left: rowsToBoard(
          boardToRows(board).map((row) => moveColumnOrRow(row, true))
        ),
        right: rowsToBoard(
          boardToRows(board).map((row) => moveColumnOrRow(row, false))
        ),
      };
    };

    const addNewPieces = (board, pieces = 1) => {
      const emptySquares = board.filter((square) => square === 0).length;
      const targetEmptySquares = new Set();

      if (emptySquares === 0) {
        return {
          board,
          targetSquares: new Set(),
        };
      }

      while (targetEmptySquares.size < pieces) {
        targetEmptySquares.add(Math.floor(Math.random() * emptySquares));
      }

      const targetSquares = new Set();
      let currentEmptySquare = 0;
      for (let i = 0; i < GameState.board.length; i++) {
        if (board[i] !== 0) continue;

        if (targetEmptySquares.has(currentEmptySquare)) {
          targetSquares.add(i);
          board[i] = Math.random() < Constants.HigherTierProbability ? 2 : 1;
        }

        currentEmptySquare++;
      }

      return {
        board,
        targetSquares,
      };
    };

    const moveBoard = async (move) => {
      if (!GameState.premove)
        GameState.premove = calculateBoard(GameState.board);

      const state = GameState.premove[move];
      const isValidMove = state.diff.some((diff) => diff !== 0);

      if (!isValidMove) return;

      const previousBoard = GameState.board;

      const { board: newBoard, targetSquares } = addNewPieces(state.board);

      GameState.board = newBoard;
      GameState.premove = calculateBoard(GameState.board);
      GameState.score =
        (GameState.score ?? 0) +
        state.combined.reduce(
          (score, points) => (points > 0 ? score + Math.pow(2, points) : score),
          0
        );
      if (GameState.score > AppState.highScore)
        AppState.highScore = GameState.score;

      if (GameState.board.some((square) => square >= Constants.MaxLevels)) {
        GameState.status = "won";
      }

      if (
        Object.values(GameState.premove).every(({ diff }) =>
          diff.every((diff) => diff === 0)
        )
      ) {
        GameState.status = "lost";
      }

      await animateState(
        previousBoard,
        newBoard,
        targetSquares,
        state.diff,
        state.combined,
        move
      );

      updateDisplayState();
    };

    const switchTheme = async (themeKey) => {
      if (!(themeKey in ThemeHistory))
        throw new Error("Attempted to switch to nonexistent theme!");

      AppState.currentThemeKey = themeKey;
      ThemeState = ThemeHistory[AppState.currentThemeKey];

      const urlParams = new URLSearchParams(window.location.search);
      urlParams.set("theme", themeKey);
      window.history.replaceState(
        {},
        undefined,
        window.location.pathname + "?" + urlParams.toString()
      );

      updateDisplayState();
    };

    const newTheme = async () => {
      const uuid = crypto.randomUUID().slice(0, 6);

      ThemeHistory[uuid] = {
        theme: "#f2a5ff",
      };

      await switchTheme(uuid);
    };

    const reset = async () => {
      const emptyBoard = () =>
        new Array(Constants.RowSize * Constants.ColumnSize).fill(0);

      const { board, targetSquares } = addNewPieces(emptyBoard(), 2);

      GameState = {
        board,
        score: 0,
      };

      await animateState(
        emptyBoard(),
        GameState.board,
        targetSquares,
        emptyBoard(),
        emptyBoard()
      );

      updateDisplayState();
    };

    const loadIdb = () => {
      const onupgradeneeded = (database, oldVersion, storeName) => {
        if (oldVersion < 1) {
          database.createObjectStore(storeName);
        }
      };

      class DB {
        constructor(dbName = "testDb", storeName = "testStore", version = 1) {
          this._config = {
            dbName,
            storeName,
            version,
          };
        }

        read(key) {
          return new Promise((resolve, reject) => {
            let dbRequest = window.indexedDB.open(
              this._config.dbName,
              this._config.version
            );

            dbRequest.onerror = (e) => {
              reject(Error("Couldn't open database."));
            };

            dbRequest.onupgradeneeded = (e) =>
              onupgradeneeded(
                e.target.result,
                e.oldVersion,
                this._config.storeName
              );

            dbRequest.onsuccess = (e) => {
              let database = e.target.result;
              let transaction = database.transaction(
                [this._config.storeName],
                "readwrite"
              );
              let objectStore = transaction.objectStore(this._config.storeName);
              let objectRequest = objectStore.get(key);

              objectRequest.onerror = (e) => {
                reject(Error("Error while getting."));
              };

              objectRequest.onsuccess = (e) => {
                resolve(objectRequest.result);
              };
            };
          });
        }

        delete(key) {
          return new Promise((resolve, reject) => {
            let dbRequest = indexedDB.open(this._config.dbName);

            dbRequest.onerror = (e) => {
              reject(Error("Couldn't open database."));
            };

            dbRequest.onupgradeneeded = (e) =>
              onupgradeneeded(
                e.target.result,
                e.oldVersion,
                this._config.storeName
              );

            dbRequest.onsuccess = (e) => {
              let database = e.target.result;
              let transaction = database.transaction(
                [this._config.storeName],
                "readwrite"
              );
              let objectStore = transaction.objectStore(this._config.storeName);
              let objectRequest = objectStore.delete(key);

              objectRequest.onerror = (e) => {
                reject(Error("Couldn't delete key."));
              };

              objectRequest.onsuccess = (e) => {
                resolve("Deleted key successfully.");
              };
            };
          });
        }

        save(key, value) {
          return new Promise((resolve, reject) => {
            let dbRequest = indexedDB.open(this._config.dbName);

            dbRequest.onerror = (e) => {
              reject(Error("Couldn't open database."));
            };

            dbRequest.onupgradeneeded = (e) =>
              onupgradeneeded(
                e.target.result,
                e.oldVersion,
                this._config.storeName
              );

            dbRequest.onsuccess = (e) => {
              let database = e.target.result;
              let transaction = database.transaction(
                [this._config.storeName],
                "readwrite"
              );
              let objectStore = transaction.objectStore(this._config.storeName);
              let objectRequest = objectStore.put(value, key); // Overwrite if exists

              objectRequest.onerror = (e) => {
                reject(Error("Error while saving."));
              };

              objectRequest.onsuccess = (e) => {
                resolve("Saved data successfully.");
              };
            };
          });
        }
      }

      window.idb = new DB("2048_db", "2048_store");
    };

    const load = async () => {
      if (!window.idb) loadIdb();

      const emptyBoard = () =>
        new Array(Constants.RowSize * Constants.ColumnSize).fill(0);

      GameState = {
        board: emptyBoard(),
        score: 0,
      };

      const localGameState = await window.idb.read("2048_State");
      if (localGameState) {
        GameState = localGameState;
      } else {
        const { board } = addNewPieces(emptyBoard(), 2);

        GameState = {
          board,
          score: 0,
        };
      }

      await animateState(
        emptyBoard(),
        GameState.board,
        GameState.board.reduce(
          (set, square, index) => (square === 0 ? set : set.add(index)),
          new Set()
        ),
        emptyBoard(),
        emptyBoard()
      );

      const localThemeHistory = await window.idb.read("2048_History");
      if (localThemeHistory) {
        ThemeHistory = localThemeHistory;
      }

      const response = await fetch(Constants.Api.DefaultThemes);
      const defaultThemes = await response.json();
      for (const [key, theme] of Object.entries(defaultThemes)) {
        ThemeHistory[key] = theme;
      }

      const localAppState = await window.idb.read("2048_App");
      if (localAppState) {
        AppState = localAppState;
      }

      let theme = AppState.currentThemeKey ?? Constants.DefaultTheme;

      const urlParams = new URLSearchParams(window.location.search);
      if (urlParams.has("theme") && urlParams.get("theme") in ThemeHistory) {
        theme = urlParams.get("theme");
      }

      await switchTheme(theme);
    };

    const save = async () => {
      if (!window.idb) loadIdb();

      await window.idb.save("2048_App", AppState);
      await window.idb.save("2048_State", GameState);
      await window.idb.save("2048_History", ThemeHistory);
    };

    const del = async () => {
      if (!window.idb) loadIdb();

      await window.idb.delete("2048_App");
      await window.idb.delete("2048_State");
      await window.idb.delete("2048_History");
    };

    const getThemedPiece = (state) => {
      if (state === 0) {
        return `<div class="board-piece invisible"><span>${Math.pow(
          2,
          state
        )}</span></div>`;
      }

      if (!ThemeState.map || !ThemeState.map[state]) {
        return `<div class="board-piece unstyled"><span>${Math.pow(
          2,
          state
        )}</span></div>`;
      }

      const themedPiece = ThemeState.map[state];

      if (themedPiece.type === "text") {
        if (themedPiece.format === "plain") {
          return `<div class="board-piece plain" style="--background: ${themedPiece.background}; --color: ${themedPiece.color}"><span>${themedPiece.value}</span></div>`;
        }

        if (themedPiece.format === "brat") {
          return `<div class="board-piece brat"><span>${themedPiece.value}</span></div>`;
        }
      }

      if (themedPiece.type === "image") {
        if (themedPiece.format === "dataurl") {
          return `<div class="board-piece image"><img src="${themedPiece.value}" /></div>`;
        }
      }
    };

    const populateNodeWithBoard = (node, board) => {
      node.innerHTML = board
        .map((state, index) => getThemedPiece(state))
        .join("");

      node.querySelectorAll(".board-piece").forEach((piece) => {
        const span = piece.querySelector("span");

        if (!span) return;

        const pieceWidth = piece.getBoundingClientRect().width;
        const pieceHeight = piece.getBoundingClientRect().height;

        let iterations = 0;
        let fontSize = parseFloat(getComputedStyle(span).fontSize);
        while (
          iterations < Constants.MaxScaleIterations &&
          Math.max(
            span.getBoundingClientRect().width / pieceWidth,
            span.getBoundingClientRect().height / pieceHeight
          ) >
            1 - 2 * Constants.PiecePaddingPercent
        ) {
          if (iterations === Constants.MaxScaleIterations - 1) {
            const scaleFactor =
              (1 - 2 * Constants.PiecePaddingPercent) /
              Math.max(
                span.getBoundingClientRect().width / pieceWidth,
                span.getBoundingClientRect().height / pieceHeight
              );
            span.style.scale = scaleFactor;
          } else {
            fontSize = fontSize * 0.85;
            span.style.fontSize = `${fontSize.toFixed(2)}px`;
          }

          iterations++;
        }
      });
    };

    const animateState = async (
      previousBoard,
      newBoard,
      targetSquares,
      diff,
      combined,
      move = "left"
    ) => {
      populateNodeWithBoard(Bindings.Board.Animation, previousBoard);

      const moveAnimationPieces = Array.from(
        document.querySelectorAll("#anim .board-piece")
      );

      Bindings.Board.Animation.classList.remove("invisible");
      Bindings.Board.State.classList.add("invisible");

      const movePx =
        parseFloat(getComputedStyle(Bindings.Board.Animation).gap) +
        moveAnimationPieces[0].getBoundingClientRect().width;

      const moveAnimationPromises = [];

      for (let i = 0; i < diff.length; i++) {
        if (diff[i] > 0) {
          const moveAnimation = moveAnimationPieces[i].animate(
            [
              { transform: "translateX(0) translateY(0)" },
              { transform: Constants.Transforms[move](diff[i] * movePx) },
            ],
            { duration: 105, easing: "ease-in", fill: "forwards" }
          );
          moveAnimationPromises.push(moveAnimation.finished);
        }
      }

      await Promise.all(moveAnimationPromises);

      populateNodeWithBoard(Bindings.Board.Animation, newBoard);

      const growAnimationPieces = Array.from(
        document.querySelectorAll("#anim .board-piece")
      );

      const growAnimationPromises = [];

      for (let i = 0; i < combined.length; i++) {
        if (targetSquares.has(i)) {
          growAnimationPieces[i].classList.remove("invisible");
          const growAnimation = growAnimationPieces[i].animate(
            [{ transform: "scale(0.6)" }, { transform: "scale(1)" }],
            { duration: 105, easing: "ease-out", fill: "forwards" }
          );
          growAnimationPromises.push(growAnimation.finished);
        } else if (combined[i] > 0) {
          const growAnimation = growAnimationPieces[i].animate(
            [
              { transform: "scale(0.6)" },
              { transform: "scale(1.1)", offset: 0.8 },
              { transform: "scale(1)" },
            ],
            { duration: 105, easing: "ease-out", fill: "forwards" }
          );
          growAnimationPromises.push(growAnimation.finished);
        }
      }

      await Promise.all(growAnimationPromises);
    };

    const updateDisplayState = () => {
      Bindings.Meta.Root.style.setProperty("--theme", ThemeState.theme);
      Bindings.Meta.Theme.setAttribute("content", ThemeState.theme);

      if (
        ThemeState.map &&
        Object.values(ThemeState.map).some(
          (themedPiece) =>
            themedPiece.type === "text" && themedPiece.format === "brat"
        )
      ) {
        document.body.classList.add("brat");
      } else {
        document.body.classList.remove("brat");
      }

      if (GameState.status) {
        Bindings.Reset.Text.innerHTML =
          GameState.status === "won"
            ? "You won! Well played."
            : "No more valid moves!";
        Bindings.Reset.Score.innerHTML = GameState.score;
        Bindings.Board.Container.classList.add("reset");
        Bindings.Reset.Board.classList.remove("invisible");
      } else {
        Bindings.Reset.Text.innerHTML = "";
        Bindings.Reset.Score.innerHTML = "";
        Bindings.Board.Container.classList.remove("reset");
        Bindings.Reset.Board.classList.add("invisible");
      }

      Bindings.Score.HighScore.innerHTML = AppState.highScore ?? 0;
      Bindings.Score.Score.innerHTML = GameState.score ?? 0;

      Bindings.Board.Board.innerHTML = new Array(
        Constants.RowSize * Constants.ColumnSize
      )
        .fill(`<div class="board-square"></div>`)
        .join("");
      Bindings.Board.State.classList.remove("invisible");
      Bindings.Board.Animation.classList.add("invisible");

      populateNodeWithBoard(Bindings.Board.State, GameState.board);

      Bindings.Dialogs.OverviewThemes.innerHTML = Object.entries(ThemeHistory)
        .sort()
        .reverse()
        .reduce(
          (innerHTML, [key, theme]) =>
            (innerHTML += `<button data-theme-key="${key}" class="small ${
              AppState.currentThemeKey === key ? "theme" : "light-gray"
            } button">
                <span>
                  <strong>
                    ${key}
                  </strong>
                </span>
              </button>`),
          ""
        );

      updateButtonBindings();

      save();
    };

    const clearBinding = (binding, event = "pointerdown") => {
      binding.Element?.removeEventListener(event, binding.Listener);
    };

    const updateBinding = (binding, callback, event = "pointerdown") => {
      binding.Element?.removeEventListener(event, binding.Listener);
      binding.Listener = callback;
      binding.Element?.addEventListener(event, binding.Listener);
    };

    const updateButtonBindings = () => {
      updateBinding(
        Bindings.Document,
        (e) => {
          if (Bindings.Dialogs.OverviewDialog.open) return;

          if (
            !e.metaKey &&
            e.key === "r" &&
            confirm("Are you sure you want to reset your game?")
          )
            reset();

          if (!GameState.status) {
            Object.entries(Constants.KeyBindings).forEach(([move, keys]) =>
              keys.includes(e.key) ? moveBoard(move) : {}
            );
          }
        },
        "keydown"
      );

      updateBinding(
        Bindings.Board.BoardTouchStart,
        (e) => {
          if (GameState.status) return;

          SwipeState.active = true;
          SwipeState.x = e.clientX;
          SwipeState.y = e.clientY;
        },
        "pointerdown"
      );
      updateBinding(
        Bindings.Board.BoardTouchEnd,
        (e) => {
          if (GameState.status) return;

          if (SwipeState.active) {
            SwipeState.active = false;
            const deltaX = e.clientX - SwipeState.x;
            const deltaY = e.clientY - SwipeState.y;

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
              if (Math.abs(deltaX) > 16)
                moveBoard(deltaX > 0 ? "right" : "left");
            } else {
              if (Math.abs(deltaY) > 16) moveBoard(deltaY > 0 ? "down" : "up");
            }
          }
        },
        "pointerup"
      );

      Bindings.Dialogs.OverviewDialog.querySelectorAll(
        "button[data-theme-key]"
      ).forEach((button) =>
        button.addEventListener("click", () => {
          const key = button.dataset.themeKey;

          if (
            AppState.currentThemeKey === key &&
            confirm(`Delete theme ${key}?`)
          ) {
            delete ThemeHistory[key];
            switchTheme(Constants.DefaultTheme);
          } else {
            switchTheme(key);
          }
        })
      );
    };

    const updateControlButtonsOnce = () => {
      updateBinding(
        Bindings.Control.OverviewButton,
        () => {
          Bindings.Dialogs.OverviewDialog.showModal();
        },
        "click"
      );
      updateBinding(
        Bindings.Control.OverviewCloseButton,
        () => {
          Bindings.Dialogs.OverviewDialog.close();
          Bindings.Control.OverviewButton.Element.blur();
        },
        "click"
      );
      updateBinding(
        Bindings.Control.OverviewNewThemeButton,
        async () => {
          newTheme();
        },
        "click"
      );
      updateBinding(
        Bindings.Control.OverviewClearDataButton,
        async () => {
          if (
            confirm(
              "Are you sure you want to clear all data? This will remove themes, high scores, and reset your current game."
            )
          ) {
            del();
            window.location.reload();
          }
        },
        "click"
      );
      updateBinding(
        Bindings.Control.ResetButton,
        () => {
          reset();
        },
        "click"
      );
      updateBinding(
        Bindings.Action.Undo,
        () => {
          // @todo
        },
        "click"
      );
      updateBinding(
        Bindings.Action.Reset,
        () => {
          if (confirm("Are you sure you want to reset your game?")) reset();
        },
        "click"
      );
    };
  </script>
  <script id="run">
    const play = async () => {
      await load();

      updateControlButtonsOnce();

      if ("serviceWorker" in navigator) {
        await navigator.serviceWorker.register("./sw.js", {
          scope: "/",
        });
      }
    };

    play();
  </script>
</html>
